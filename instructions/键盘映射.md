# OtoKeyboard

- 主要分为两部分：鼠标映射，键盘映射

## 鼠标映射
## 键盘映射
 ### 整体思路
 需要一个控件，位置处于其余控件的上层，便于接收各种事件(如按键事件，手势事件)，并进行相应地处理同时自身不消费事件，处理完毕后，传递给下层的控件；另外需要一个配置界面。
 
 ### 代码实现流程
 - BaseView.java 接受和处理所有事件
 - ViewManager.java 管理BaseView
 - ControlView.java 配置界面，设置按键映射
 
 #### 具体实现
  - MainActivity.java 开启按钮，点击事件，启动BaseView
``` 
  btn_openView.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
          ViewManager.getInstance(MainActivity.this).showBase();
          v.setVisibility(View.GONE);
          mInfo.setText(MainActivity.this.getString(R.string.info));
      }
  });
``` 
 - BaseView.java 接收F12按键，启动配置界面ControlView
 ``` 
 @Override
 public boolean dispatchKeyEvent(final KeyEvent event) {
    // 接收按键F12，打开ControlView2
    final int keyCode = event.getKeyCode();
    switch (keyCode) {
        case KeyEvent.KEYCODE_F12:
           MainActivity.mHandler.sendEmptyMessage(0);
           return true;
    }
 ``` 
 - ControlView.java 用户设置按键映射
 ``` 
  @Override
  public boolean dispatchKeyEvent(KeyEvent event) {
      // 接收并处理事件
      ......
  }
  
  // 轮盘点击事件监听，主要处理轮盘的拖动和缩放；
  class DirectionKeyTouchListener implements View.OnTouchListener {
      @Override
      public boolean onTouch(View v, MotionEvent event) {
          ......
      }
  }
  
  // 轮盘鼠标指针悬停监听，主要判断鼠标指针是否进入缩放范围
  private class DirectionKeyHoverListener implements View.OnHoverListener {
      @Override
      public boolean onHover(View v, MotionEvent event) {
          ......
      }
  }
``` 
- BaseView.java 接收事件并处理
``` 
// dispatchKeyEvent 接收事件
@Override
 public boolean dispatchKeyEvent(final KeyEvent event) {
    ......
    if (event.getAction() == KeyEvent.ACTION_DOWN
            && event.getRepeatCount() == 0) {
        if (mDirectionKeys.contains(keyCode)) {
            // 按键为轮盘方向键down事件
            ......
        } else if (mFunctionKeys.contains(event.getKeyCode())) {
            // 处理功能键down事件
            ......
        }
    } else if (event.getAction() == KeyEvent.ACTION_UP) {
        if (mDirectionKeys.contains(event.getKeyCode())) {
            // 处理轮盘方向键up事件
            ......
        } else if (mFunctionKeys.contains(event.getKeyCode())) {
            // 处理功能键
            ......
    }
 }
 
 // 处理轮盘方向键
 public void processDirectionKeyMapping(final Instrumentation in, final int eventType, 
                             final float x, final float y, final boolean needDown,
                             final float downX, final float downY) {
     ......
 }
 
 // 处理功能键
 public void processFunctionKeyMapping(final Instrumentation in, final int eventType,
                   final float x, final float y, final boolean needMove, final float downX, 
                   final float downY, final float moveX, final float moveY) {
     ......
 } 
``` 
#### 技术难点
- 1.添加BaseView,保证其在所有应用最上层，能够接受并处理所有物理按键事件，并将鼠标点击事件穿透给下层应用处理；
``` 
  public void showBase() {
      hideControl();
      // 初始化BaseView
      mBaseView = new BaseView(context);
      windowManager = 
          (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
      // 设置窗口属性
      if (mBaseViewParams == null) {
          mBaseViewParams = new WindowManager.LayoutParams();
          mBaseViewParams.width = MainActivity.screenWidth;
          mBaseViewParams.height = MainActivity.screenHeight;
          mBaseViewParams.gravity = Gravity.TOP | Gravity.LEFT;
          // TYPE_SYSTEM_ALERT 保证BaseView在所有应用最上层
          mBaseViewParams.type = 
              WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
          // FLAG_NOT_TOUCHABLE 保证不接收鼠标点击事件，穿透给下层应用处理
          mBaseViewParams.flags = 
              WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
          mBaseViewParams.format = PixelFormat.RGBA_8888;
      }
      // 添加
      windowManager.addView(mBaseView, mBaseViewParams);
  }
``` 
- 2.物理按键模拟点击
``` 
  // 初始化
  private Instrumentation mInstrumentation = new Instrumentation();
  // 使用
  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
``` 
